{"version":3,"sources":["index.tsx"],"names":["labelDiv","document","body","appendChild","createElement","label","createTextNode","container","classList","add","Streamlit","events","addEventListener","RENDER_EVENT","event","data","detail","textContent","args","options","icons","index","label_visibility","clearable","style","visibility","display","childNodes","length","forEach","option","i","pill","icon_span","onclick","unselect","contains","querySelectorAll","el","remove","setComponentValue","theme","font","color","textColor","base","setFrameHeight","setComponentReady"],"mappings":"mJAAA,kBAEMA,EAAWC,SAASC,KAAKC,YAAYF,SAASG,cAAc,UAC5DC,EAAQL,EAASG,YAAYF,SAASK,eAAe,KACrDC,EAAYN,SAASC,KAAKC,YAAYF,SAASG,cAAc,QACnEG,EAAUC,UAAUC,IAAI,aA0FxBC,IAAUC,OAAOC,iBAAiBF,IAAUG,cAnF5C,SAAkBC,GAEhB,IAAMC,EAAQD,EAAkCE,OAEhDX,EAAMY,YAAcF,EAAKG,KAAL,MACpB,IAAIC,EAAUJ,EAAKG,KAAL,QACVE,EAAQL,EAAKG,KAAL,MACRG,EAAQN,EAAKG,KAAL,MACRI,EAAmBP,EAAKG,KAAL,iBACnBK,EAAYR,EAAKG,KAAL,UAGS,WAArBI,IACFtB,EAASwB,MAAMC,WAAa,UAEL,cAArBH,IACFtB,EAASwB,MAAME,QAAU,QAGS,IAAhCnB,EAAUoB,WAAWC,QACvBT,EAAQU,SAAQ,SAACC,EAAgBC,GAC/B,IAAIC,EAAOzB,EAAUJ,YAAYF,SAASG,cAAc,QAGxD,GAFA4B,EAAKxB,UAAUC,IAAI,QAEfW,EAAO,CACT,IAAIa,EAAYD,EAAK7B,YAAYF,SAASG,cAAc,SACxD6B,EAAUzB,UAAUC,IAAI,QACxBwB,EAAUhB,YAAcG,EAAMW,GAGhCC,EAAK7B,YAAYF,SAASK,eAAewB,IAErCC,IAAMV,GACRW,EAAKxB,UAAUC,IAAI,YAGrBuB,EAAKE,QAAU,WAIb,IAAIC,EAAWZ,GAAaS,EAAKxB,UAAU4B,SAAS,YAEpD7B,EAAU8B,iBAAiB,aAAaR,SAAQ,SAACS,GAC/CA,EAAG9B,UAAU+B,OAAO,eAGlBJ,EAGFzB,IAAU8B,kBAAkB,SAE5B9B,IAAU8B,kBAAkBT,GAC5BC,EAAKxB,UAAUC,IAAI,iBAOvBM,EAAK0B,QACPzC,EAASwB,MAAMkB,KAAO3B,EAAK0B,MAAMC,KACjC1C,EAASwB,MAAMmB,MAAQ5B,EAAK0B,MAAMG,UACV,SAApB7B,EAAK0B,MAAMI,KACb5C,SAASC,KAAKmC,iBAAiB,SAASR,SAAQ,SAACS,GAC/CA,EAAG9B,UAAUC,IAAI,WAGnBR,SAASC,KAAKmC,iBAAiB,SAASR,SAAQ,SAACS,GAC/CA,EAAG9B,UAAU+B,OAAO,YAW1B7B,IAAUoC,oBAQZpC,IAAUqC,oBAIVrC,IAAUoC,mB","file":"static/js/main.5cc6ef2a.chunk.js","sourcesContent":["import { Streamlit, RenderData } from \"streamlit-component-lib\"\n\nconst labelDiv = document.body.appendChild(document.createElement(\"label\"))\nconst label = labelDiv.appendChild(document.createTextNode(\"\"))\nconst container = document.body.appendChild(document.createElement(\"div\"))\ncontainer.classList.add(\"container\")\n\n/**\n * The component's render function. This will be called immediately after\n * the component is initially loaded, and then again every time the\n * component gets new data from Python.\n */\nfunction onRender(event: Event): void {\n  // Get the RenderData from the event\n  const data = (event as CustomEvent<RenderData>).detail\n\n  label.textContent = data.args[\"label\"]\n  let options = data.args[\"options\"]\n  let icons = data.args[\"icons\"]\n  let index = data.args[\"index\"]\n  let label_visibility = data.args[\"label_visibility\"]\n  let clearable = data.args[\"clearable\"]\n  // console.log(captions)\n\n  if (label_visibility === \"hidden\") {\n    labelDiv.style.visibility = \"hidden\"\n  }\n  if (label_visibility === \"collapsed\") {\n    labelDiv.style.display = \"none\"\n  }\n\n  if (container.childNodes.length === 0) {\n    options.forEach((option: string, i: number) => {\n      let pill = container.appendChild(document.createElement(\"div\"))\n      pill.classList.add(\"pill\")\n\n      if (icons) {\n        let icon_span = pill.appendChild(document.createElement(\"span\"))\n        icon_span.classList.add(\"icon\")\n        icon_span.textContent = icons[i]\n      }\n\n      pill.appendChild(document.createTextNode(option))\n\n      if (i === index) {\n        pill.classList.add(\"selected\")\n      }\n\n      pill.onclick = function () {\n        // If the element is clearable, let the user unselect by clicking on the pill\n        // again. I.e. if this pill (which is clicked) was already selected before, we\n        // unselect it later.\n        let unselect = clearable && pill.classList.contains(\"selected\")\n\n        container.querySelectorAll(\".selected\").forEach((el) => {\n          el.classList.remove(\"selected\")\n        })\n\n        if (unselect) {\n          // Need to pass a string here and convert it to None on the Python side.\n          // If setting null, the components lib returns the \"default\" value (=index).\n          Streamlit.setComponentValue(\"None\")\n        } else {\n          Streamlit.setComponentValue(i)\n          pill.classList.add(\"selected\")\n        }\n      }\n    })\n  }\n\n  // Style according to the app theme.\n  if (data.theme) {\n    labelDiv.style.font = data.theme.font\n    labelDiv.style.color = data.theme.textColor\n    if (data.theme.base === \"dark\") {\n      document.body.querySelectorAll(\".pill\").forEach((el) => {\n        el.classList.add(\"dark\")\n      })\n    } else {\n      document.body.querySelectorAll(\".pill\").forEach((el) => {\n        el.classList.remove(\"dark\")\n      })\n    }\n\n    // TODO: Gray out the component and disable click if it's disabled.\n  }\n\n  // We tell Streamlit to update our frameHeight after each render event, in\n  // case it has changed. (This isn't strictly necessary for the example\n  // because our height stays fixed, but this is a low-cost function, so\n  // there's no harm in doing it redundantly.)\n  Streamlit.setFrameHeight()\n}\n\n// Attach our `onRender` handler to Streamlit's render event.\nStreamlit.events.addEventListener(Streamlit.RENDER_EVENT, onRender)\n\n// Tell Streamlit we're ready to start receiving data. We won't get our\n// first RENDER_EVENT until we call this function.\nStreamlit.setComponentReady()\n\n// Finally, tell Streamlit to update our initial height. We omit the\n// `height` parameter here to have it default to our scrollHeight.\nStreamlit.setFrameHeight()\n"],"sourceRoot":""}